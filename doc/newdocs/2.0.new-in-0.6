
Lightweight C++, version 0.6
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This text documents the new features that appeared in 0.6
There are also the abstract template classes and the
virtual inheritance declarations which are presented in
external documents.


0. Accessing Virtual Variables Without Instance
-----------------------------------------------

  Virtual variables which belong in the virtual table can
be accessed without an object instance with the syntax
<classname>.<member>

  For example:

	class A {
	virtual	int count;
	};

	class B : A {};

	int main ()
	{
		int total = A.count + B.count;
	}



1. Structure By Reference calls Virtual
---------------------------------------

In the case:

	class A {
	virtual int f ();
	}

	void foo (A a1)
	{
		A a2;

		a1.f ();	// virtual call
		a2.f ();	// member call
	}

  For object a1, the call will be through the virtual table pointer to
function, while for a2 there will be a direct call of a2_mEmBeR function.
This is the right thing since except from the syntactical ease
of structures-by-reference, a1 is really a pointer and not a specific
instance known at compile-time.


2. Anonymous object call Constructor
------------------------------------

  In a local declaration the object name may be omitted if there is
a constructor call. For example:

	class A {
		int x;
		A (int i) { x = i; }
	};

	int foo ()
	{
		A (32);
	}

  In this case a temporary object of type A will be allocated, its
constructor will be called and then the destructor (if exists).
Then the object will die.

This is useful generally if an object is an alrgorithm which does
what it has to do at the contructor call.


3. _lwc_config_
----------------

 In order to pass options to the lwc compiler, there is a special keyword
_lwc_config_.  Example:

	_lwc_config_ {
		// stop compilation if version less than 0.6
		version 0,6;

		// enable this debug flag which traces declarations
		lwcdebug DCL_TRACE;

		// send debugs there
		lwcdebug > "out.log";

		// or to stderr
		//lwcdebug > 2;

		// C compatibility mode. Structures passed by value.
		struct_by_value;

		// inline all virtual tables by default
		inline_virtual_tables;

		// const virtual tables. Unable to set values to
		// virtual variables however
		const_virtual_tables;

		// forward declaration of an explanatory section below
		virtual_inheritance_declarations;

		// auto comment the generated C code
		comment_C "
		/* File automatically generated by lwc compiler.
		 * still, Copyright (c) 1987, Stepan Trofimovits, though
		 * It's mine, it's mine, it's mine.
		 * NO WARRANTY FOR MERCHANTABILITY
		 * DO YOU KNOW OF ANY PRODUCT THAT GIVES WARRANTY FOR MERCHANTABILITY?
		 */";
	}

	int foo ()
	{
		...
	}

The _lwc_config_ reserved word must be followed by braces inside which
various options can be set.  The option "version major,minor" for example
instructs the lwc compiler to terminate if its version is older than the
one required.  See the file lwc_config.c from the lwc source for the
possible options.




[B] Virtual Inheritance
=======================

Virtual inheritance is a complex case.  Some of even the most advanced languages of
the world (Java, D, C#) don't support it.  lwc tries to achieve a more lightweight
implementation without losing the power of virtual inheritance.


1. Avoid data in Virtual Base Classes if you can
------------------------------------------------

  Generally, virtual base classes without data members are virtuous,
both in lightweight C++ and in C++.  Here is the wrong way and the
right way to implement virtual inheritance for a case where the virtual
functions will not need base-object's data members.

WRONG way:

	class A {
		int x;
	virtual int f1 () = 0;
	virtual int f2 () = 0;

		// this uses 'x' and calls 'f1' and 'f2'
		int main ();
	};

	class B : virtual A {
		int f1 ();
	};

	class C : virtual A {
		int f2 ();
	};

	class D : B, C {};

RIGHT way:

	class A {
	virtual int f1 () = 0;
	virtual int f2 () = 0;
	};

	class A0 : virtual A {
		int x;

		// uses 'x', 'f1', 'f2'
		int main ();
	};

	class B : virtual A {
		int f1 ();
	};

	class C : virtual A {
		int f2 ();
	};

	class D : A0, B, C {};

Remember that in C++ too.  In lwc you can study the difference by looking at
the generated code.  Moreover, in lwc in such cases the objects are position
independent and can be copied around.


2. Error about manual creation of virtual table
-----------------------------------------------

  In the rare case of sequential virtual inheritance you may get this
message.  It will happen in this dummy case for example:

	class A {
	virtual int f ();
	};

	class B : virtual A {};

	//class X : virtual A {};

	class C : virtual B {};

  The downcast offset for B->C cannot be placed in the virtual table of A
because then the order of declaration would matter (B must be always
declared before in X in all files).  For that lwc asks for the generation of
a virtual table for B (unlike C++ which takes the initiative to always
create a new virtual table for classes with virtual parents, to be prepared for
such a -rare- case). 
A virtual table can be manually created with "virtual;" or "inline virtual;":

	class B : virtual A {
		inline virtual;
	};

 A virtual table will be generated anyway for B if it introduces new virtual
functions though...


