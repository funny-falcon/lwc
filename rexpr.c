#include "global.h"

struct obflag objective = { .yes = false, .recording = false };

/******************************************************************************

	Rewrite expressions

	all expressions may have to be rewritten.
	To maintain readable output however, we try to keep the expression
	as unchanged as possible. Indeed, if there's nothing to be
	changed the expression will be unchanged. For that we treat syntactical
	parenthesis as an extra operator, which does nothing but preserves
	the correct priority.

******************************************************************************/

#define alloctok(x) (Token*) mallocint (x)
#define intdup_alloca(X, Y) {\
		X = (int*) allocaint (intlen (Y) + 1);\
		intcpy (X, Y);\
	}

static inline void intcattok (Token *str, Token t)
{
	while (*str != -1) str++;
	*str++ = t;
	*str = -1;
}

/* from the info on e->operators[], as generated by the break-expr module */
/* create the subexpression strings in the branches */
static Token **mkbranch (bexpr *e)
{
	Token **ret, fop;
#ifdef	DEBUG
	if (debugflag.PEXPR_EXTREME) {
		PRINTF ("\nExpress:");
		INTPRINT (e->expr);
		PRINTF ("\ne->nop == %i %i %i\n", e->nop, e->operators [0], intlen (e->expr));
		if (e->nop==2) PRINTF ("op2=%i\n", e->operators [1]);
		PRINTF ("***[  %s  ]*** e->et=%i\n", expand (e->expr [e->operators [0]]), e->et);
	}
#endif
	if (e->nop == 0) return 0;
	fop = e->expr [e->operators [0]];
	if (fop == '{') {
		ret = (Token**) malloc (2 * sizeof (Token*));
		ret [0] = intndup (e->expr + 1, 1 + e->operators [1] - e->operators [0]);
		ret [1] = 0;
		return ret;
	}
	if (fop == '(' && e->et == PARENTH_SYNTAX) {
		ret = (Token**) malloc (2 * sizeof (Token*));
		ret [0] = intndup (e->expr + 1, e->operators [1] - e->operators [0] - 1);
		ret [1] = 0;
		return ret;
	}
	if (fop == '(' && e->et == PARENTH_CAST) {
		ret = (Token**) malloc (3 * sizeof (Token*));
		ret [0] = intndup (e->expr + 1, e->operators [1] - e->operators [0] - 1);
		ret [1] = intdup (e->expr + e->operators [1] + 1);
		ret [2] = 0;
		return ret;
	}
	if (fop == '[') {
		ret = (Token**) malloc (3 * sizeof (Token*));
		ret [0] = intndup (e->expr, e->operators [0]);
		ret [1] = intdup (e->expr + e->operators [0] + 1);
		ret [1] [intlen (ret [1]) - 1] = -1;
		ret [2] = 0;
		return ret;
	}
	if (fop == '(' && e->et == PARENTH_FCALL) {
		int i, ip;
		int argc = e->nop - 1;
		if (e->operators [0] + 1 == e->operators [1])
			argc = 0;
		/* alloc one more for possible addition of 'this' arg */
		ret = (Token**) malloc ((argc + 3) * sizeof (Token*));
		for (i = ip = 0; i < argc + 1; ip = e->operators [i++] + 1)
			ret [i] = intndup (e->expr + ip, e->operators [i] - ip);
		ret [i] = 0;
		if (e->operators [0] == 1 && ret [0][0] == RESERVED_postfix) {
			Token *s;
			if (argc < 2) expr_error ("too few arguments to postfix()");
			for (i = 2, ip = 2; i < argc + 1; i++)
				ip += intlen (ret [i]) + 1;
			s = mallocint (ip);
			s [0] = -1;
			for (i = 2; i < argc + 1; i++) {
				intcat (s, ret [i]);
				free (ret [i]);
				ret [i] = 0;
				if (i != argc) intcattok (s, ',');
			}
			ret [2] = s;
			e->et = PARENTH_POSTFIX;
		}
		return ret;
	}
	if (fop == RESERVED___declexpr__) {
		ret = (Token**) malloc (2 * sizeof (Token*));
		ret [0] = intdup (e->expr);
		ret [0][intlen (ret [0]) - 1] = -1;
		ret [1] = 0;
		return ret;
	}
	if (fop == RESERVED_new || fop == RESERVED_localloc) {
		ret = (Token**) malloc (2 * sizeof (Token*));
		ret [0] = intdup (e->expr + 1);
		ret [1] = 0;
		return ret;
	}
	if (e->nop == 1) {
		if (e->operators [0] == 0) {
			/* prefix operator */
			ret = (Token**) malloc (2 * sizeof (Token*));
			ret [0] = intdup (e->expr + 1);
			ret [1] = 0;
			return ret;
		}
		if (e->expr [e->operators [0]+1] == -1) {
			/* postfix ++ or -- */
			ret = (Token**) malloc (2 * sizeof (Token*));
			ret [0] = intdup (e->expr);
			ret [0] [intlen (ret [0]) - 1] = -1;
			ret [1] = 0;
			return ret;
		}
		ret = (Token**) malloc (3 * sizeof (Token*));
		ret [0] = intndup (e->expr, e->operators [0]);
		ret [1] = intdup (&e->expr [e->operators [0] + 1]);
		ret [2] = 0;
		return ret;
	}
	if (fop == '?') {
		ret = (Token**) malloc (4 * sizeof (Token*));
		ret [0] = intndup (e->expr, e->operators [0]);
		ret [1] = intndup (e->expr + e->operators [0] + 1, e->operators [1] - e->operators [0] - 1);
		ret [2] = intdup (e->expr + e->operators [1] + 1);
		ret [3] = 0;
		return ret;
	}
	return 0;
}

static bool fork_branches (bexpr *e)
{
	return (e->branch = mkbranch (e)) != 0;
}

/* free all subexpressions */
static void freebranches (bexpr *e)
{
	int i;
	Token **branch = e->branch;
	if (!branch) return;
	for (i = 0; branch [i]; i++)
		free (branch [i]);
	free (branch);
}

/******************************************************************************
	Not only do we have to break the expressions, but we also
	have to rejoin them later. Doh!
******************************************************************************/

static Token *join_expr_opcenter (Token *e1, Token op, Token *e2)
{
	Token *r = alloctok (intlen (e1) + 2 + intlen (e2));
	sintprintf (r, ISTR (e1), op, ISTR (e2), -1);

#ifdef DEBUG
	if (debugflag.PEXPR) {
	PRINTF ("express: ");
	INTPRINT (e1);
	PRINTF (COLS"%s"COLE" ", expand (op));
	INTPRINTN (e2);
	}
#endif

	return r;
}

static Token *join_expr_opleft (Token op, Token *e)
{
	Token *r = alloctok (2 + intlen (e));
	r [0] = op;
	intcpy (r + 1, e);

#ifdef DEBUG
	if (debugflag.PEXPR) {
	PRINTF ("express: "COLS"%s"COLE, expand (op));
	INTPRINTN (e);
	}
#endif

	return r;
}

static Token *enclose_parenth_expr (Token *e)
{
	Token *r = alloctok (4 + intlen (e));
	sintprintf (r, '(', ISTR (e), ')', -1);

#ifdef DEBUG
	if (debugflag.PEXPR) {
	PRINTF ("express: "COLS"("COLE);
	INTPRINT (e);
	PRINTF (COLS")"COLE"\n");
	}
#endif

	return r;
}

static inline bool simpleexpr (Token*);

static Token *addressize (Token *e)
{
	Token *r;

	if (simpleexpr (e))
		return join_expr_opleft ('&', e);
	if (e [0] == '(' && e [1] == '*' && ISSYMBOL (e [2])) {
		/* optimize &(*z) to z */
		if (e [3] == ')' && e [4] == -1)
			return sintprintf (alloctok (2), e [2], -1);
		int l = intlen (e) - 1;
		/* optimize &(*x(....)) to x(....), and &(*x[...]) to x[...] */
		if ((e [3] == '(' && skip_buffer_parenthesis (e, 4) == l)
		|| (e [3] == '[' && skip_buffer_brackets (e, 4) == l)) {
			sintprintf (r = alloctok (l), ISTR (&e [2]), -1);
			r [intlen (r) - 1] = -1;
			return r;
		}
	}
	r = enclose_parenth_expr (e);
	e = join_expr_opleft ('&', r);
	free (r);
	return e;
}

static Token *ptrize (Token *e)
{
	Token *r = alloctok (intlen (e) + 4);
	sintprintf (r, '(', '*', ISTR (e), ')', -1);
	free (e);
	return r;
}

static Token *hier_upcast (Token *expr, Token *path, bool ptrpath)
{
	Token *ret = alloctok (intlen (expr) + intlen (path) + 5);
	if (simpleexpr (expr))
	sintprintf (ret, ptrpath ? BLANKT : '&', ISTR (expr), POINTSAT, ISTR (path), -1);
	else
	sintprintf (ret, ptrpath ? BLANKT : '&', '(', ISTR (expr), ')', POINTSAT, ISTR (path), -1);
	return ret;
}

static Token *hier_upcast_nonull (Token *expr, Token *path, bool ptrpath, recID rb, recID rd)
{
	if (zero_offset (rd, rb))
		return hier_upcast (expr, path, ptrpath);

	Token *ret = alloctok (intlen (expr) + intlen (path) + 5);
	sintprintf (ret, i_upcast_null_safe (rb, rd, path, ptrpath), '(', ISTR (expr), ')', -1);
	return ret;
}

/*****************************************************************************
	some utilities
*****************************************************************************/

inline bool isstructure (typeID t)
{
	int *s = open_typeID (t);
	return s [0] >= 0 && s [1] == -1;
}

inline bool isreference (typeID t)
{
	return open_typeID (t)[0] >= REFERENCE_BASE;
}

static inline bool isnumeric (typeID t)
{
	t = bt_promotion (t);//
	return t == typeID_int || t == typeID_float;
}

inline bool ispointer (typeID t)
{
	int *s = open_typeID (t);
	return s [1] != -1 && s [1] != '(';
}

inline bool isstructptr (typeID t)
{
	int *s = open_typeID (t);
	return dbase_of (t) >= 0 && s [1] == '*' && s [2] == -1;
}

static inline bool isfptr (typeID t)
{
	int *s = open_typeID (t);
	return s [1] == '*' && s [2] == '(';
}

static inline bool lvaluate (typeID t)
{
	int *s = open_typeID (t);
	return !(s [1] == '[' || (s [0] >= 0 && s [1] == -1) || s [1] == '(');
}

static inline bool simpleexpr (Token *e)
{
	return e [1] == -1 || (e [1] == '.' && e [3] == -1)
		 || (e [1] == POINTSAT && e [3] == -1)
		 || (e [0] == '(' && e [2] == ')' && e [3] == -1);
}

static typeID expr_is_class (Token *e)
{
	if (e [1] != -1) return 0;
	recID rr = lookup_object (e [0]) ?: e [0] == RESERVED__CLASS_ ? objective.class : 0;
	return rr ? ptrdown (pthis_of_struct (rr)) : 0;
}

static void check_pure_datam (typeID t, Token e)
{
	if (base_of (t) == B_PURE) {
		if (objective.recording) {
			usage_call_pure ();
			raise_skip_function ();
		}
		else expr_errort ("Non-auto uses generic data member", e);
        }
}

static void undo_declexprs (int);
/*****************************************************************************

	rewrite()

*****************************************************************************/

typedef struct {
	Token *e;
	typeID t;
	bool isconst, lvalue, refalloca, tmpv, dferd;
} rewrret;

#define INIT_RWR { .refalloca=false, .tmpv=false, .dferd=false }

static void dereference_call (rewrret *r)
{
	if ((r->dferd = isreference (r->t))) {
		r->t = ptrdown (dereference (r->t));
		r->e = ptrize (r->e);
		r->lvalue = true;
	}
}

static bool MODE_DEREFERENCE;

static void dereference_var (rewrret *r)
{
	if ((r->dferd = isreference (r->t))) {
		r->t = dereference (r->t);
		if (!MODE_DEREFERENCE) {
			r->t = ptrdown (r->t);
			r->e = ptrize (r->e);
			r->lvalue = true;
		}
	}
}

/* declaration-expressions moved before the expression and dtored after it */
struct declexpr {
	void *cp_scope;
	Token *de [40], obj [40];
	int c, off;
} *dexpr;

static Token *cpoint_rewrite_expression (Token*, rewrret*);
static Token *rewrite_expression (Token*, rewrret*);

static void rewr_branch_cpoint (bexpr *e, int i, rewrret *r)
{
	Token *rwr = cpoint_rewrite_expression (e->branch [i], r);
	if (rwr != e->branch [i]) {
		free (e->branch [i]);
		e->branch [i] = rwr;
	}
}

static void rewr_branch (bexpr *e, int i, rewrret *r)
{
	Token *rwr = rewrite_expression (e->branch [i], r);
	if (rwr != e->branch [i]) {
		free (e->branch [i]);
		e->branch [i] = rwr;
	}
}


/* terminal subexpression, constant value */
static Token *rewr_const (Token *e, rewrret *r)
{
	r->t = type_of_const (e [0]);
	r->isconst = true;
	r->lvalue = false;

	return r->e = e;
}

/* RESERVED_this */
static Token *rewr_this (Token *e, rewrret *r)
{
	if (!objective.yes)
		expr_error ("'this' is only available inside members sir");
	if (!objective.have_this)
		expr_error ("'this' not available in modular functions");
	if (objective.recording)
		usage_notok ();
	r->isconst = false;
	r->lvalue = true;	/* interesting */
	r->t = objective.classP;

	return r->e = e;
}

/* Feature: class constants usable */
static Token *maybe_class_const (Token t, rewrret *r, recID o)
{
	Token rep = lookup_class_const (o, t);
	if (rep == -1) return 0;
	if (objective.recording)
		usage_tconst (rep);
	Token *ex = alloctok (2);
	ex [0] = rep;
	ex [1] = -1;
	rewrite_expression (ex, r);
	return r->e;
}

/* * * * * Feature: "Encapsulation" * * * * */
/* lookup a variable name in a class scope, including inheritance
 * also does virtual variables and modular data members as well
 */
static Token *lookup_object_scope (Token e, rewrret *r)
{
	typeID t;
	Token path [64], glob_name = 0;

	t = lookup_variable_member (objective.class, e, path, !objective.polymorph, &glob_name);

	if (t != -1 && glob_name) {
		sintprintf (r->e = alloctok (3), glob_name, -1);

		goto leave;
	}

	if (t != -1) {
		if (objective.recording)
			usage_memb (e);
		check_pure_datam (t, e);
	}

	/* Feature: virtual variables */
	if (t == -1) {
		Token *cval;
		t = lookup_virtual_varmemb (objective.class, e, path, !objective.polymorph, &cval);

		if (t != -1 && !objective.polymorph) {
			if (objective.recording)
				usage_vvar (cval);
			/* go to virtual table instance directly (no 'this') */
			if (!cval) cval = path;
			intcpy (r->e = alloctok (1 + intlen (cval)), cval);
			goto leave;
		}
	}
	/* ^^^^^^^^^^^^^^^^^^^^^^^^^^ */

	/* Feature: class constants */
	if (t == -1 || !objective.have_this)
		return maybe_class_const (e, r, objective.class);
	/* ^^^^^^^^^^^^^^^^^^^^^^^^ */

	r->e = alloctok (5 + intlen (path));

	/* do we need parenthesis here? I don't think so */
	sintprintf (r->e, RESERVED_this, POINTSAT, ISTR (path), -1);
leave:
	r->t = t;
	dereference_var (r);
	r->isconst = false;
	r->lvalue = lvaluate (r->t);
	return r->e;
}

/* terminal subexpression, identifier */
static Token *rewr_terminal (Token *e, rewrret *r)
{
	Token gnn;
	typeID t;
	r->dferd = false;

	if (is_enumconst (e [0])) {
		r->t = typeID_int;
		r->isconst = true;
		r->lvalue = false;
		return r->e = e;
	}

	if ((t = lookup_local_obj (e [0], &gnn)) != -1) {

		if (gnn) e [0] = gnn;

		/* Feature: structure by reference */
		if (t >= REFERENCE_BOOST) {
			r->t = t - REFERENCE_BOOST;
			e = join_expr_opleft ('*', e);
			r->e = enclose_parenth_expr (e);
			free (e);
			r->lvalue = r->dferd = true;
			return r->e;
		}
		/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */

		r->t = t;
		r->e = intdup (e);
		dereference_var (r);
		r->isconst = false;
		r->lvalue = lvaluate (t);
		return r->e;
	}

	/* Feature: member function accessing variable members */
	if ((objective.yes) && lookup_object_scope (e [0], r))
		return r->e;
	/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */

	/* Feature: not member function expr, but uses class consts */
	if (top_scope)
		if ((r->e = maybe_class_const (e [0], r, current_scope [top_scope])))
			return r->e;
	/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */

	if ((t = lookup_global_object (e [0])) != -1) {
		r->e = intdup (e);
		r->t = t;
		dereference_var (r);
		r->isconst = false;
		r->lvalue = lvaluate (t);
		return r->e;
	}

	if ((t = lookup_function_symbol (e [0])) != -1) {
		r->t = ptrup (t);
		r->isconst = true;
		r->lvalue = false;
		return r->e = e;
	}

	if (local_name && local_name == e [0]) {
		r->e = intdup (e);
		r->t = local_type;
		dereference_var (r);
		r->isconst = false;
		r->lvalue = lvaluate (r->t);
		return r->e;
	}

	expr_error_undef (e [0], 0);

	return 0;
}

/* syntactical parenthesis */
static Token *rewr_parenthesis (bexpr *e, rewrret *r)
{
	/*++++++++++++++++++*/
	rewr_branch (e, 0, r);
	/*++++++++++++++++++*/
	return r->e = enclose_parenth_expr (e->branch [0]);
}

/* comma separated expressions */
static Token *rewr_comma (bexpr *e, rewrret *r, rewrret *R)
{
	r->isconst &= R->isconst;
	r->lvalue = false;
	r->refalloca |= R->refalloca;
	r->e = join_expr_opcenter (e->branch [0], e->expr [e->operators [0]], e->branch [1]);

	return r->e;
}

/* cast. All casts are valid and let C compiler complain */
/* jump back into the dcl module for rewrite of type */
/* In the case we have two pointers to classes of the same
   hierarchy, more needs to be done to ensure the correct
   displacement */
static Token *rewr_cast (bexpr *e, rewrret *r)
{
	typeID t = eval_cast (&e->branch [0]);

	/*++++++++++++++++++*/
	rewr_branch (e, 1, r);
	/*++++++++++++++++++*/

	/* Feature:      Casts in inheritance */
	if (isstructptr (r->t) && isstructptr (t)) {
		Token *path;
		recID ext = aliasclass (base_of (r->t));
		recID cst = aliasclass (base_of (t));
		int vp;

		if (ext == cst)
			r->e = intdup (e->branch [1]);
		/* UpCast */
		else if ((vp = is_ancestor (ext, cst, &path, false)))
			r->e = hier_upcast_nonull (e->branch [1], path, vp != 1, cst, ext);
		else if (is_ancestor (cst, ext, &path, false)) {
		/* DownCast */
			r->e = alloctok (intlen (e->branch [1]) + 5);
			sintprintf (r->e, (zero_offset (cst, ext) ? i_downcast_function : i_downcast_null_safe)
				    (ext, cst), '(', ISTR (e->branch [1]), ')', -1);
		} else goto not_relatives;
	/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
	} else not_relatives: {
		r->e = alloctok (intlen (e->branch [0]) + 3 + intlen (e->branch [1]));
		sintprintf (r->e, '(', ISTR (e->branch [0]), ')', ISTR (e->branch [1]), -1);
	}

	r->t = t;

#ifdef DEBUG
	if (debugflag.PEXPR) {
	PRINTF ("express: "COLS"("COLE);
	INTPRINT (e->branch [0]);
	PRINTF (COLS")"COLE" ");
	INTPRINT (e->branch [1]);
	PRINTF ("\n");
	}
#endif

	return r->e;
}

/* Operators with two integer operands */
static Token *rewr_bitop (bexpr *e, rewrret *r, rewrret *R)
{
	R->t = bt_promotion (R->t); //
	r->t = bt_promotion (r->t); //
	if (R->t != typeID_int || r->t != typeID_int)
		expr_error ("integer operand expected");
	r->isconst &= R->isconst;
	r->lvalue = false;
	r->refalloca |= R->refalloca;
	r->e = join_expr_opcenter (e->branch [0], e->expr [e->operators [0]], e->branch [1]);

	return r->e;
}

/* address of */
static Token *rewr_address (bexpr *e, rewrret *r)
{
	if (r->lvalue || isstructure (r->t))
		r->t = ptrup (r->t);

	/* XXX: if global name overriden by inner scope, this is not const */
	r->isconst = e->branch [0][1] == -1
			 && lookup_global_object (e->branch [0][0]) != -1;
	r->lvalue = false;

	r->e = addressize (e->branch [0]);
/*
	if (e->branch [0][0] == '(' && e->branch [0][1] == '*' && e->branch [0][3] == ')'
	 && e->branch [0][4] == -1)
		r->e = sintprintf (alloctok (2), e->branch [0][2], -1);
	else
		r->e = join_expr_opleft ('&', e->branch [0]);
*/
	return r->e;
}

static Token *rewr_ptrind (bexpr *e, rewrret *r)
{
	r->isconst = false;
	r->t = ptrdown (r->t);
	r->lvalue = lvaluate (r->t);
	r->e = join_expr_opleft ('*', e->branch [0]);

	return r->e;
}

/* operator with two numeric operands (float or int) */
static Token *rewr_numop (bexpr *e, rewrret *r, rewrret *R)
{
	R->t = bt_promotion (R->t); //
	r->t = bt_promotion (r->t); //
	if (R->t != typeID_int && R->t != typeID_float)
		expr_error ("numeric operand expected");
	if (r->t != typeID_int && r->t != typeID_float)
		expr_error ("XXX numeric operand expected");

	r->isconst &= R->isconst;
	if (r->t == typeID_int && R->t == typeID_float)
		r->t = typeID_float;
	r->lvalue = false;
	r->refalloca |= R->refalloca;
	r->e = join_expr_opcenter (e->branch [0], e->expr [e->operators [0]], e->branch [1]);

	return r->e;
}

/* relational operators. Weirdness like comparing a pointer with
   a float, comparing structures and comparing different pointers,
   are left to the C compiler to complain about.  */
static Token *rewr_relational (bexpr *e, rewrret *r, rewrret *R)
{
	// #*#*#*#*#* pointers && hierarchy #*#*#*#*#*#
	if (R->t != r->t && isstructptr (R->t) && isstructptr (r->t)) {
		int vp;
		recID r1 = aliasclass (base_of (R->t));
		recID r2 = aliasclass (base_of (r->t));
		Token *path, *tmp;

		if (r1 == r2);
		else if ((vp = is_ancestor (r2, r1, &path, false))) {
			tmp = hier_upcast_nonull (e->branch [1], path, vp == 2, r1, r2);
			free (e->branch [1]);
			e->branch [1] = tmp;
		} else if ((vp = is_ancestor (r1, r2, &path, false))) {
			tmp = hier_upcast_nonull (e->branch [0], path, vp == 2, r2, r1);
			free (e->branch [0]);
			e->branch [0] = tmp;
		} else expr_errortt ( "comparison between distinct pointer "
			"types lacks a cast", name_of_struct (r1), name_of_struct (r2));
	} //##*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

	r->isconst &= R->isconst;
	r->lvalue = false;
	r->t = typeID_int;
	r->refalloca |= R->refalloca;
	r->e = join_expr_opcenter (e->branch [0], e->expr [e->operators [0]], e->branch [1]);

	return r->e;
}

/* binary complement */
static Token *rewr_complement (bexpr *e, rewrret *r)
{
	r->t = bt_promotion (r->t);//
	if (r->t != typeID_int)
		expr_error ("~integer only");
	r->lvalue = false;
	r->e = join_expr_opleft ('~', e->branch [0]);

	return r->e;
}

/* logical negation */
static Token *rewr_not (bexpr *e, rewrret *r)
{
	r->t = typeID_int;
	r->lvalue = false;
	r->e = join_expr_opleft ('!', e->branch [0]);

	return r->e;
}

/* jump back into the dcl module for type rewrite */
static Token *rewr_sizeof_type (bexpr *e, rewrret *r)
{
	Token *tmp = intdup (e->expr + 2);

	eval_cast (&tmp);
	r->t = typeID_int;
	r->isconst = true;
	r->lvalue = false;
	r->e = alloctok (intlen (tmp) + 4);
	sintprintf (r->e, RESERVED_sizeof, '(', ISTR (tmp), ')', -1);
	free (tmp);

#ifdef DEBUG
	if (debugflag.PEXPR) {
	PRINTF ("express: "COLS);
	INTPRINT (r->e);
	PRINTF (COLE"\n");
	}
#endif

	return r->e;
}

/* sizeof. The actual value of the size is of no interest and we couldn't
   know it anyway.  */
static Token *rewr_sizeof (bexpr *e, rewrret *r)
{
	r->t = typeID_int;
	r->isconst = true;
	r->lvalue = false;
	r->e = join_expr_opleft (RESERVED_sizeof, e->branch [0]);

	return r->e;
}

/* * * * * * * Feature: new * * * * * * * * */
/* * * * * * * and localloc * * * * * * * * */
static Token *rewr_new (bexpr *e, rewrret *r)
{
	Token akey = e->expr [e->operators [0]];
	Token alloc = akey == RESERVED_new ? new_wrap :
		      akey == RESERVED_localloc ? INTERN_alloca : 0;
	Token bn = e->expr [1] == RESERVED__CLASS_ ?
		 name_of_struct (objective.class) : e->expr [1];
	recID o;
	bool must_ctor;
	Token *vector_expr, *multi_ctor_stmt = 0;
	Token vec;

	if (!(o = lookup_object (bn)))
		expr_errort ("No such object", bn);
	if (bn == RESERVED__CLASS_ && objective.recording)
		usage_notok ();

	Can_instantiate (o);	/* question */

	r->refalloca = alloc == INTERN_alloca;
	must_ctor = e->expr [2] == '(' 
			|| (ISSYMBOL (e->expr [2]) && e->expr [3] == '(')
  			|| (e->expr [2] != '[' && has_void_ctor (o));

	Token tid = internal_identifier1 ();

 	if (e->expr [2] == '[') {
		rewrret R = INIT_RWR;
		vector_expr = intdup (e->expr + 3);
		vector_expr [intlen (vector_expr) - 1] = -1;
		/*------------------------------------------------*/
		vector_expr = rewrite_expression (vector_expr, &R);
		/*------------------------------------------------*/
		r->refalloca |= R.refalloca;
	} else vector_expr = 0;

	/* Overloaded operator new */
	if (alloc == new_wrap && !(objective.yes &&
	 objective.class == o && objective.efunc == RESERVED_new))
		alloc = lookup_newdel_operator (RESERVED_new, o) ?: new_wrap;
	/* *********************** */

	if (!must_ctor && !need_construction (o) && !multi_ctor_stmt) {
		OUTSTREAM O = new_stream ();

		outprintf (O, '(', '(', iRESERVED_struct (o), bn, '*', ')', alloc, '(', -1);
		if (in2 (alloc, new_wrap, INTERN_alloca))
			outprintf (O, RESERVED_sizeof, '(', iRESERVED_struct (o), bn, ')', -1);
		if (vector_expr)
			outprintf (O, '*', '(', ISTR (vector_expr), ')', ')', ')', -1);
		else outprintf (O, ')', ')', -1);
		r->isconst = r->lvalue = false;
		r->t = pthis_of_struct (o);
		return r->e = combine_output (O);
	}

	OUTSTREAM s = new_stream ();
	outprintf (s, '(', '{', -1);

	if (vector_expr)
		outprintf (s, RESERVED_int, vec = internal_identifier2 (), '=',
			   ISTR (vector_expr), ';', -1);
	else vec = 0;

	outprintf (s, iRESERVED_struct (o), bn, '*', tid, -1);
	alloc_and_init (s, o, tid, alloc, vec);

	typeID pt = pthis_of_struct (o);

	if (must_ctor) {
		Token *ex, *er;
		rewrret R = INIT_RWR;
		int i = 2;

		ex = alloctok (intlen (e->expr) + 4);
		sintprintf (ex, tid, POINTSAT, ISSYMBOL (e->expr [2]) ?
			    e->expr [i++] : RESERVED_ctor, -1);
		if (e->expr [i] == '(')
			intcat (ex, e->expr + i);
		else sintprintf (ex + 3, '(', ')', -1);
		open_local_scope ();
		enter_local_obj (tid, pt);
		/*-----------------------------*/
		er = rewrite_expression (ex, &R);
		/*-----------------------------*/
		close_local_scope ();
		free (ex);
		outprintf (s, ISTR (er), ';', -1);
		free (er);
	}

	/* Feature: append code for array ctors */
	if (multi_ctor_stmt)
		outprintf (s, ISTR (multi_ctor_stmt), -1);

	outprintf (s, tid, ';', '}', ')', -1);
	r->isconst = r->lvalue = false;
	r->t = pt;

	return r->e = combine_output (s);
}

static Token *rewr_fcall (bexpr*, rewrret*);

/* * * * * * * * Feature: delete * * * * * * * */
static Token *rewr_delete (bexpr *e, rewrret *r)
{
	typeID argt [] = { 0, INTERNAL_ARGEND };
	flookup F;
	Token *sv = allocaint (intlen (e->branch [0]) + 1), cdel = delete_wrap;
	intcpy (sv, e->branch [0]);
	bool vcall;
	recID rec = -1;

	/*++++++++++++++++++*/
	rewr_branch (e, 0, r);
	/*++++++++++++++++++*/

	if (((vcall = isstructptr (r->t)) || isstructure (r->t))
	&& lookup_function_member (rec = base_of (r->t), RESERVED_dtor, argt, &F, true)) {

		SET_MAYTHROW (F);
		rewrret R = INIT_RWR;
		Token *ne = mallocint (intlen (sv) + 8);
#define VC vcall ? POINTSAT : '.'
		if (simpleexpr (sv))
			sintprintf (ne, ISTR (sv), VC, RESERVED_dtor, '(', ')', -1);
		else sintprintf (ne, '(', ISTR (sv), ')', VC, RESERVED_dtor, '(', ')', -1);
		bexpr E = { .expr = ne };
		break_expr (&E);
		fork_branches (&E);
		rewr_fcall (&E, &R);
		freebranches (&E);
		free (e->branch [0]);
		e->branch [0] = R.e;
	}

	if (!(objective.yes && objective.class == rec && objective.efunc == RESERVED_delete))
		cdel = lookup_newdel_operator (RESERVED_delete, rec) ?: delete_wrap;

	r->e = alloctok (intlen (e->branch [0]) + 4);
	sintprintf (r->e, cdel, '(', ISTR (e->branch [0]), ')', -1);
	r->t = typeID_void;
	r->isconst = false;
	r->lvalue = false;

	return r->e;	
}

/* subtract and pointer arithmetic semantics */
static Token *rewr_sub(bexpr *e, rewrret *r, rewrret *R)
{
	r->t = bt_promotion (r->t);//
	R->t = bt_promotion (R->t);//
	r->refalloca |= R->refalloca;
	r->isconst &= R->isconst;
	r->lvalue = false;
	if (isnumeric (R->t) && isnumeric (r->t))
		r->t = (R->t == typeID_int && r->t == typeID_int)
			 ? typeID_int : typeID_float;
	else if (ispointer (R->t))
		if (r->t == typeID_int)
			r->t = R->t;
		else if (ispointer (r->t))
			r->t = typeID_int;
		else expr_error ("Invalid pointer arithmetic");
	else expr_error ("It's not possible to subtract these");
	r->e = join_expr_opcenter (e->branch [0], '-', e->branch [1]);
	return r->e;
}

/* addition and pointer arithmetic */
static Token *rewr_add (bexpr *e, rewrret *r, rewrret *R)
{
	r->t = bt_promotion (r->t);//
	R->t = bt_promotion (R->t);//
	r->refalloca |= R->refalloca;
	r->isconst &= R->isconst;
	r->lvalue = false;

	if (isnumeric (R->t) && isnumeric (r->t))
		r->t = (R->t == typeID_int && r->t == typeID_int)
			 ? typeID_int : typeID_float;
	else if (ispointer (R->t))
		if (r->t != typeID_int)
			expr_error ("Pointer plus non-integer");
		else r->t = R->t;
	else if (ispointer (r->t)) {
		if (R->t != typeID_int)
			expr_error ("Pointer plus non-integer");
	} else expr_error ("It's not possible to add structures");

	r->e = join_expr_opcenter (e->branch [0], '+', e->branch [1]);

	return r->e;
}

/* unary sign */
static Token *rewr_usign (bexpr *e, rewrret *r)
{
	if (!isnumeric (r->t))
		expr_error ("+/- must be applied to numbers");
	r->lvalue = false;
	r->e = join_expr_opleft (e->expr [e->operators [0]], e->branch [0]);

	return r->e;
}

/* inc/dec */
static Token *rewr_incdec (bexpr *e, rewrret *r)
{
	r->isconst = false;
	if (e->operators [0] == 0)
		r->e = join_expr_opleft (e->expr [e->operators [0]], e->branch [0]);
	else {
		r->e = alloctok (intlen (e->branch [0]) + 2);
		intcpy (r->e, e->branch [0]);
		intcattok (r->e, e->expr [e->operators [0]]);

#ifdef DEBUG
	if (debugflag.PEXPR) {
	PRINTF ("expREss: ");
	INTPRINT (e->branch [0]);
	PRINTF (COLS"%s"COLE"\n", expand (e->expr [e->operators [0]]));
	}
#endif
	}

	return r->e;
}

/* booleans */
static Token *rewr_boolean (bexpr *e, rewrret *r, rewrret *R)
{
	r->refalloca |= R->refalloca;
	r->isconst &= R->isconst;
	r->lvalue = false;
	r->t = typeID_int;
	r->e = join_expr_opcenter (e->branch [0], e->expr [e->operators [0]], e->branch [1]);

	return r->e;
}

/* assignment of structures of hierarchy */
static Token *rewr_assign_ancest (recID b, recID d, Token *rval, Token *path, bool ptrpath)
{
	Token *ex;

	if (need_construction (b)) {
		if (need_vbase_alloc (b))
			parse_error (0, "Sorry. Can't do. Can't assign structures "
					"with virtual inheritance just like that. "
					"Please use a copy() function or something");
		Token tid = internal_identifier1 ();
		OUTSTREAM o = new_stream ();

		outprintf (o, '(', '{', iRESERVED_struct (b), name_of_struct (b),
			   tid, '=', ptrpath ? '*' : BLANKT,
			   '(', ISTR (rval), ')', '.', ISTR (path), ';', -1);
		gen_vt_init (o, b, tid, false);
		outprintf (o, tid, ';', '}', ')', -1);
		ex = combine_output (o);
	} else {
		ex = alloctok (intlen (path) + intlen (rval) + 5);
		sintprintf (ex, ptrpath ? '*' : BLANKT, '(', ISTR (rval),
			    ')', '.', ISTR (path), -1);
	}
	free (rval);

	return ex;
}

/* assignments: let C compiler complain for crap */
static Token *rewr_assign (bexpr *e, rewrret *r, rewrret *R)
{
	r->refalloca |= R->refalloca;

	if (R->t == r->t) {

		if (isstructure (r->t) && isstructure (R->t)) same_struct:
		if (has_const_members (base_of (r->t))) {
			/* Feature: assign structures with const members using memcpy */
#			define VOIDCAST '(', RESERVED_void, '*', ')', '&'
			recID bn = aliasclass (base_of (R->t));

			r->e = alloctok (3*intlen (e->branch [0]) + intlen (e->branch [1]) + 25);
			r->isconst = false;
			sintprintf (r->e, '(', '*', '(', iRESERVED_struct (bn), name_of_struct (bn),
				   '*', ')', INTERN_memcpy, '(', VOIDCAST,
				    ISTR (e->branch [0]), ',', VOIDCAST, ISTR (e->branch [1]),
				    ',', RESERVED_sizeof, ISTR (e->branch [0]), ')', ')', -1);
			return r->e;
		}

	/* Feature: assign a pointer to a derrived structure to
	   a pointer to a base structure (automatic cast)      */
	} else if (isstructptr (r->t) && r->t != R->t && isstructptr (R->t)) {
		Token *path;
		recID lvr = aliasclass (base_of (R->t));
		recID rer = aliasclass (base_of (r->t));
		int vp;
		if (lvr != rer && (vp = is_ancestor (rer, lvr, &path, false))) {
			Token *tmp = hier_upcast_nonull (e->branch [1], path, vp == 2, lvr, rer);
			free (e->branch [1]);
			e->branch [1] = tmp;
		}
	}
	/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */

	/* Feature: structure assignments */
	else if (isstructure (R->t) && isstructure (r->t)) {
		Token *path;
		recID lvr = aliasclass (base_of (R->t));
		recID rer = aliasclass (base_of (r->t));
		int vp;
		if (lvr == rer) goto same_struct;
		if (lvr != rer && (vp = is_ancestor (rer, lvr, &path, false))) {
			e->branch [1] = rewr_assign_ancest (base_of (R->t),
					 base_of (r->t), e->branch [1], path, vp == 2);
		}
		/* else let compiler refuse */
	}
	/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */

	r->isconst = false;
	r->e = join_expr_opcenter (e->branch [0], '=', e->branch [1]);

	return r->e;
}

/* operator assignments */
static Token *rewr_opassign (bexpr *e, rewrret *r, rewrret *R)
{
	r->isconst = false;
	r->e = join_expr_opcenter (e->branch [0], e->expr [e->operators [0]], e->branch [1]);

	return r->e;
}

/* Conditional expression. E2 and E3 must be converted to common type! */
/* one of E2 and E3 will not be evaluated, and has NO side effects !!! */
static Token *rewr_conditional (bexpr *e, rewrret *r)
{
	rewrret R1 = INIT_RWR , R2 = INIT_RWR;
	bool omitted = e->branch [1][0] == -1;

	/*++++++++++++++++++++++++++++*/
	rewr_branch_cpoint (e, 2, &R2);
	rewr_branch (e, 0, r);
	/* GNU omitted middle operand. Handle accordingly */
	if (!omitted) rewr_branch_cpoint (e, 1, &R1);
	else R1 = *r;
	/*++++++++++++++++++++++++++++*/

	r->refalloca |= R1.refalloca | R2.refalloca;
	r->isconst &= R1.isconst & R2.isconst;
	r->lvalue = false;

	if (R1.t != R2.t) {
		R1.t = bt_promotion (R1.t);//
		R2.t = bt_promotion (R2.t);//
	}

	if (R1.t == R2.t)
		r->t = R1.t;
	else if (R1.t == typeID_int)
		if (R2.t == typeID_int) r->t = typeID_int;
		else if (R2.t == typeID_float) r->t = typeID_float;
		else if (isstructure (R2.t)) goto impossible;
		else r->t = R2.t;
	else if (R2.t == typeID_int)
		if (R1.t == typeID_float) r->t = typeID_float;
		else if (isstructure (R1.t)) goto impossible;
		else r->t = R1.t;
	/* Feature: "? E1:E2" if E1 and E2 are both pointers to
	   structures of the same hierarchy, then there has to
	   be casting to a common type. Otherwise the C compiler
	   will rightly complain #*#*#*#*#*#*#*#*#*#*#*#*#*#*# */
	else if (isstructptr (R1.t) && isstructptr (R2.t)) {
		int vp;
		recID r1 = aliasclass (base_of (R1.t));
		recID r2 = aliasclass (base_of (R2.t));
		Token *path, *tmp;

		if (r1 == r2);
		else if ((vp = is_ancestor (r2, r1, &path, false))) {
			tmp = hier_upcast_nonull (e->branch [2], path, vp == 2, r1, r2);
			free (e->branch [2]);
			e->branch [2] = tmp;
			r->t = R1.t;
		} else if ((vp = is_ancestor (r1, r2, &path, false))) {
			// if omitted, use e->branch[0]
			tmp = hier_upcast_nonull (e->branch [omitted ? 0:1], path, vp == 2, r2, r1);
			free (e->branch [1]);
			e->branch [1] = tmp;
			r->t = R2.t;
		} else expr_errortt ( "conditional expression between distinct pointer "
				"types lacks a cast", name_of_struct (r1), name_of_struct (r2));
	/* #*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*# */
	} else impossible: {
		r->t = R1.t;
//		expr_warn ("Could not convert to sane type in conditional");
	}

	r->e = alloctok (intlen (e->branch [0]) + 4
			 + intlen (e->branch [1]) + intlen (e->branch [2]));
	sintprintf (r->e, ISTR (e->branch [0]), '?', ISTR (e->branch [1]), ':',
		    ISTR (e->branch [2]), -1);

#ifdef DEBUG
	if (debugflag.PEXPR) {
	PRINTF ("express: ");
	INTPRINT (e->branch [0]);
	PRINTF (COLS"?"COLE" ");
	INTPRINT (e->branch [1]);
	PRINTF (COLS":"COLE" ");
	INTPRINTN (e->branch [2]);
	}
#endif

	return r->e;
}

static Token *rewr_member (bexpr *e, rewrret *r)
{
	Token path [64], glob_name = 0;
	typeID rt;

	/* * * * * Feature: Access virtual variable members w/o instance * * * */
	if (e->branch [0][1] == -1 && !is_object_in_scope (e->branch [0][0])
	&& lookup_object (e->branch [0][0])) {
		Token base = e->branch [0][0], memb = e->branch [1][0];

		if ((base == RESERVED__CLASS_ || e->branch [1][0] == RESERVED__v_p_t_r_)
		&& objective.recording)
			usage_notok ();
		recID rec = lookup_object (base);
		if (e->branch [1][0] == RESERVED__v_p_t_r_) {
			sintprintf (r->e = alloctok (3), '&', get_class_vptr (rec), -1);;
			r->t = typeID_voidP;
			r->isconst = true;
			r->lvalue = true;
			return r->e;
		}
		vtvar V = access_virtual_variable (rec, memb);
		if (V.t == -1) {
			rt = lookup_variable_member (rec, memb, path, 0, &glob_name);
			if (rt != -1) {
				check_pure_datam (rt, memb);
				if (glob_name)
					goto domemb;
			}
			expr_errort ("No such virtual variable member", memb);
		}
		e->branch [0][0] = V.rec;
		r->t = V.t;
		r->e = memb == RESERVED_typeid && V.expr ? intdup (V.expr) :
				 join_expr_opcenter (e->branch [0], '.', V.memb);
		dereference_var (r);
		r->lvalue = lvaluate (r->t);
		r->isconst = false;
		return r->e;
		// =====> leave
	}
	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */

	/*++++++++++++++++++*/
	rewr_branch (e, 0, r);
	/*++++++++++++++++++*/

	if (!isstructure (r->t))
		expr_error ("Not a structure");
	rt = lookup_variable_member (base_of (r->t), e->branch [1][0], path, !r->dferd, &glob_name);

	if (rt == -1) {
		/* in the case of vtbl variable, because of compile-time polymorphism
		 * the final expression goes directly to apropriate vtbl instance */
		rt = lookup_virtual_varmemb (base_of (r->t), e->branch [1][0], path, !r->dferd, 0);
		if (rt == -1)
			expr_errort ("No such member.", e->branch [1][0]);

		if (r->dferd)
			r->e = join_expr_opcenter (e->branch [0], '.', path);
		else r->e = intdup (path);
		r->t = rt;
		dereference_var (r);
		r->lvalue = lvaluate (r->t);
		r->isconst = false;	/* interesting together with RESERVED_const vtbl */
		return r->e;
	} else check_pure_datam (rt, e->branch [1][0]);

domemb:
	r->t = rt;
	if (!glob_name)
		r->e = join_expr_opcenter (e->branch [0], '.', path);
	else sintprintf (r->e = alloctok (2), glob_name, -1);
	dereference_var (r);
	r->lvalue = lvaluate (r->t);
	r->isconst = false;

	return r->e;
}

#define possible_undo int undode = dexpr->c;
#define UNDO_REWRITE if (dexpr->c != undode) undo_declexprs (undode);

/* member from pointer to record */
static Token *rewr_pmember (bexpr *e, rewrret *r)
{
	recID rt;
	Token path [64], glob_name = 0;
	typeID argt [] = { 0, INTERNAL_ARGEND };
	flookup F;
	Token *sv = allocaint (intlen (e->branch [0]) + 1);
	intcpy (sv, e->branch [0]);
	bool svthis = sv [0] == RESERVED_this && sv [1] == -1;

	/*++++++++++++++++++*/
	possible_undo
	rewr_branch (e, 0, r);
	/*++++++++++++++++++*/

	/* Feature: operator overloading -> */
	if ((isstructure (r->t) /*|| svthis*/)
	&& lookup_function_member (base_of (r->t), RESERVED_oper_pointsat, argt, &F, true)) {
		UNDO_REWRITE
		SET_MAYTHROW (F);
		Token *ne = mallocint (intlen (sv) + 10);
		sintprintf (ne, '(', ISTR (sv), svthis ? POINTSAT : '.', RESERVED_oper_pointsat,
			    '(', ')', ')', POINTSAT, e->branch [1][0], -1);
		return r->e = rewrite_expression (ne, r);
	}
	/* ->->->->->->->->->->->->->->->-> */

	r->t = ptrdown (r->t);
	if (!isstructure (r->t))
		expr_error ("Not a structure");
	rt = lookup_variable_member (base_of (r->t), e->branch [1][0], path, false, &glob_name);
	if (rt == -1)
		rt = lookup_virtual_varmemb (base_of (r->t), e->branch [1][0], path, false, 0);
	else check_pure_datam (r->t, e->branch [1][0]);
	if (rt == -1)
		expr_errort ("No such member", e->branch [1][0]);
	r->t = rt;
	if (!glob_name)
		r->e = join_expr_opcenter (e->branch [0], POINTSAT, path);
	else sintprintf (r->e = alloctok (2), glob_name, -1);
	dereference_var (r);
	r->lvalue = lvaluate (r->t);
	r->isconst = false;

	return r->e;
}

/*[ array reference ]*/
static Token *rewr_array (bexpr *e, rewrret *r, rewrret *R)
{
	r->t = bt_promotion (r->t);//
	R->t = bt_promotion (R->t);//
	r->isconst = false;
	r->refalloca |= R->refalloca;
	if (ispointer (R->t) && r->t == typeID_int)
		r->t = ptrdown (R->t);
	else if (ispointer (r->t) && R->t == typeID_int)
		r->t = ptrdown (r->t);
	else expr_error ("pointer [integer]");
	r->lvalue = lvaluate (r->t);
	r->e = alloctok (intlen (e->branch [0]) + 3 + intlen (e->branch [1]));
	sintprintf (r->e, ISTR (e->branch [0]), '[', ISTR (e->branch [1]), ']', -1);

#ifdef DEBUG
	if (debugflag.PEXPR) {
	PRINTF ("express: ");
	INTPRINT (e->branch [0]);
	PRINTF (COLS"["COLE" ");
	INTPRINT (e->branch [1]);
	PRINTF (COLS"]"COLE"\n");
	}
#endif

	return r->e;
}

/* Entire compound statement has to be recursively rewritten */
static typeID lasttype;
static Token *rewr_statmexpr (bexpr *e, rewrret *r)
{
	r->e = rewrite_compound_statement (e->branch [0] + 1);
	r->t = lasttype;
	r->isconst = false;
	r->lvalue = false;
	return r->e;
}

/* Feature: calling member functions from normal functions */
/* 'e' is the broken function call expression and
   'eb' is the broken member access expression
   For example, in:  ojb.foo (x, y);
    e is:  'obj.foo' ( 'x', 'y' )
    eb is: 'obj' . 'foo' 
   The code will alter e to be:
	'obj_foo_' ( '&obj', 'x', 'y' )
   Unless there is no such member function but there is a data member
   which is a pointer to function.  In this case return -1.
************************************************************/
static typeID rewr_membcall (OUTSTREAM O, bexpr *e, bexpr *eb, typeID argt[], bool tmpvs[], int *argc, flookup *F)
{
	int	i, r=r;
	Token	*path = 0;
	rewrret	R = INIT_RWR;
	recID obj;
	bool	throuptr = eb->expr [eb->operators [0]] == POINTSAT;
	Token	mf = *eb->branch [1];

	/* Feature: Call modular function with <class>.<func> () */
	if (eb->branch [0][1] == -1 && !is_object_in_scope (eb->branch [0][0])
	&& lookup_object (eb->branch [0][0])) {
		recID rec = lookup_object (e->branch [0][0]);

		/* special class.__init__ (void*) function, to initialize
		   and object to the given memory address */
		if (mf == RESERVED__i_n_i_t_) {
			e->branch [0][0] = i_init_object (rec);
			e->branch [0][1] = -1;
			int p [10];
			sintprintf (p, typeID_voidP, '(', typeID_voidP, INTERNAL_ARGEND, -1);
			return enter_type (p);
		}

		if (!lookup_function_member (rec, mf, argt, F, true) || !(F->flagz & FUNCP_MODULAR))
		{
			if (!objective.yes || !isancestor (objective.class, rec))
				expr_errort ("No such modular function", mf);
			/* Feature: class.func() to call parent func */
			SET_MAYTHROW ((*F));
			sintprintf (frealloc (&eb->branch [0], 10), '(', '*', '(',
				    name_of_struct (rec), '*', ')', RESERVED_this, ')', -1);
			goto proceed;
		}
		SET_MAYTHROW ((*F));
		if (eb->branch [0][0] == RESERVED__CLASS_ && objective.recording)
			usage_notok ();
		e->branch [0][0] = F->oname;
		e->branch [0][1] = -1;
		return F->t;
	}
	/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */

proceed:
again:;
	Token	*sv = allocaint (intlen (eb->branch [0]) + 1);

	intcpy (sv, eb->branch [0]);

	possible_undo
	if (eb->branch [0][1] == -1 && !throuptr) {
		/* manually rewrite branch which is terminal symbol func arg */
		typeID t = lookup_local_obj (eb->branch [0][0], 0);
		if (t >= REFERENCE_BOOST) {
			/* RightThing: Reference is really ptr */
			R.t = ptrup (t - REFERENCE_BOOST);
			throuptr = true;
			eb->expr [eb->operators [0]] = POINTSAT;
		} else goto not_a_reference;
	} else not_a_reference: {
		/*++++++++++++++++++++++*/
		rewr_branch (eb, 0, &R);
		/*++++++++++++++++++++++*/
		if (R.dferd && !throuptr) {
			R.t = ptrup (R.t);
			eb->branch [0] = addressize (eb->branch [0]);
			throuptr = true;
			eb->expr [eb->operators [0]] = POINTSAT;
		}
	}

	/* Feature: operator overloading -> */
	if (throuptr && isstructure (R.t)) {
		typeID xargt [] = { 0, INTERNAL_ARGEND };
		flookup F;
		
		if (!lookup_function_member (base_of (R.t), RESERVED_oper_pointsat, xargt, &F,true))
			goto err;
		SET_MAYTHROW (F);
		UNDO_REWRITE
		sintprintf (frealloc (&eb->branch [0], intlen (sv) + 10),
			   '(', ISTR (sv), '.', RESERVED_oper_pointsat, '(', ')', ')', -1);
		goto again;
	}
	/* ->->->->->->->->->->->->->->->-> */

	if ((throuptr && !isstructptr (R.t)) || (!throuptr && !isstructure (R.t))) err:
		expr_error ("invalid object. Not a structure/pointer-to-structure");
	obj = base_of (R.t);

	if (R.refalloca)
		expr_error ("Aaaaaarghhh! alloca in arguments (object base)");

	if (throuptr) {
		Token vpath [128];

		if (!lookup_virtual_function_member (obj, mf, argt, vpath, F))
			goto eelse;

		SET_MAYTHROW ((*F));
		recID r1 = aliasclass (obj);
		recID r2 = aliasclass (base_of (argt [0]));

		/* Calling virtual function from the virtual table */
		if (r1 != r2)
			r = is_ancestor (r1, r2, &path, false);

		// ... this was before... borked?
		//e->branch [0][0] = i_member_virtual (r2, mf, argt, F);
		e->branch [0][0] = i_member_virtual (base_of (argt [0]), mf, argt, F);
		e->branch [0][1] = -1;
		/* ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^*/

	} else eelse: {
		if (!lookup_function_member (obj, mf, argt, F, true)) {
			/* data member which is a pointer to function */
			/* Support for good old C libraries */
			Token tpa [128];

			may_throw = true;
			typeID t = lookup_variable_member (obj, mf, tpa, false, 0);
			if (t == -1) expr_errort ("No such member function", mf);
			if (!isfptr (t)) expr_errort ("Not a pointer to function", mf);
			return -1;
		}

		SET_MAYTHROW ((*F));

		if (objective.recording && F->flagz & FUNCP_PURE)
			usage_call_pure ();

		recID r1 = aliasclass (obj);
		recID r2 = aliasclass (base_of (argt [0]));

		if (r1 != r2)
			r = is_ancestor (r1, r2, &path, !throuptr);

		e->branch [0][0] = F->oname;
		e->branch [0][1] = -1;

		/* Feature: call the default args first */
		if (F->dflt_args) {
			int c;
			for (c = 0; F->dflt_args [c]; c++);
			e->branch = (Token**) realloc (e->branch, (*argc + c + 3) * sizeof (Token*));
			for (i = 0; i < c; i++) {
				rewrret R = INIT_RWR;
				e->branch [*argc + i + 1] = intdup (F->dflt_args [i]);

				/*+++++++++++++++++++++++++++++++*/
				rewr_branch (e, *argc + i + 1, &R);
				/*+++++++++++++++++++++++++++++++*/

				argt [*argc + i + 1] = R.t;
				tmpvs [*argc + i + 1] = R.tmpv;
			}
			e->branch [i + *argc + 1] = 0;
			argt [*argc += c] = INTERNAL_ARGEND;
		}
		/*-++-**-++-**-++-**-++-**-++-**-++-**-+*/
	}

	if (F->flagz & FUNCP_MODULAR)
		return F->t;

	/* if cant get address, dont */
	if ((tmpvs [0] = R.tmpv && (!path ? !throuptr : r == 1)))
		argt [0] = ptrdown (argt [0]);

	/* make room for the new argument */
	for (i = 1; e->branch [i]; i++);
	for (; i > 0; i--) e->branch [i + 1] = e->branch [i];

	/* add the 'this' argument */
	Token *thisarg;
	thisarg = eb->branch [0];

	if (path) {
		/* Inherited function */
		e->branch [1] = alloctok (intlen (path) + intlen (thisarg) + 7);
		if (thisarg [1] == -1)
			sintprintf (e->branch [1], r == 1 && !tmpvs [0] ? '&' : BLANKT, thisarg [0],
				    throuptr ? POINTSAT : '.', ISTR (path), -1);
		else
			sintprintf (e->branch [1], r == 1 && !tmpvs [0] ? '&' : BLANKT,
				    '(', ISTR (thisarg), ')',
				    throuptr ? POINTSAT : '.', ISTR (path), -1);
	} else  e->branch [1] = !throuptr && !tmpvs [0] ? addressize (thisarg) : intdup (thisarg);

	++*argc;

	return F->t;
}

/* Convert __enumstr__ to a function */
static Token *do_enumstr (bexpr *e, rewrret *r)
{
	Token enumn = 0;

	if (e->nop - 1 != 2 || !issymbol (enumn = e->expr [2]) || !is_enum (enumn))
		expr_error ("__enumstr__ (ENUM, val)");

	/*++++++++++++++++++++++*/
	rewr_branch (e, 2, r);
	/*++++++++++++++++++++++*/

	r->isconst = false;
	r->lvalue = false;
	r->t = funcreturn (typeID_ebn_f);
	return r->e = sintprintf (alloctok (intlen (e->branch [2]) + 6), i_enum_by_name (enumn),
		'(', ISTR (e->branch [2]), ')', -1);
}

static Token *do_inset (bexpr *e, rewrret *r)
{
	int i;
	OUTSTREAM O = new_stream ();
	Token rt = internal_identifiern (99);

	/*++++++++++++++++++++++*/
	rewr_branch (e, 1, r);
	/*++++++++++++++++++++++*/

	outprintf (O, '(', '{', RESERVED_int, rt, '=', RESERVED_0, ';', RESERVED_switch, '(',
		   ISTR (e->branch [1]), ')', -1);
	for (i = 2; i < e->nop; i++)
		outprintf (O, RESERVED_case, ISTR (e->branch [i]), ':', -1);
	outprintf (O, rt, '=', RESERVED_1, ';', rt, ';', '}', ')', -1);

	r->lvalue = r->isconst = false;
	r->t = typeID_int;
	return r->e = combine_output (O);
}

/* Feature: __declexpr__ (object declaration w/ ctor) */
static Token *rewr_declexpr (bexpr *e, rewrret *r)
{
	Token *dc;
	OUTSTREAM O;
	Token nn;
	void *backscope = 0;
	int cc = dexpr->c++;

	nn = dexpr->obj [cc] = name_uniq_var (dexpr->off + cc);

	if (e->branch [0][0] != RESERVED___declexpr__) {
		int argc = e->nop - 1, i;
		if (e->operators [1] == e->operators [0] + 1)
			argc = 0;

		outprintf (O = new_stream (), ISTR (e->branch [0]), nn, -1);
		if (argc) {
			output_itoken (O, '(');
			for (i = 0; i < argc; i++) {
				outprintf (O, ISTR (e->branch [i + 1]), -1);
				if (i + 1 < argc) output_itoken (O, ',');
			}
			output_itoken (O, ')');
		}
		output_itoken (O, ';');
		dc = combine_output (O);
	} else {
		int k, j;
		Token *br = e->branch [0] + 2;
		intcatc (intcpy (dc = alloctok (intlen (br) + 3), br), ';');
		
		for (k = 0; ISDCLFLAG (dc [k]); k++);
		for (; issymbol (dc [k]); k++)
			if (lookup_object (dc [k])) break;
		if (!issymbol (dc [k])) expr_error ("malformed __declexpr__ ()");
		for (j = intlen (dc); j > k; j--) dc [j + 1] = dc [j];
		dc [k + 1] = nn;
	}

	if (active_scope () != dexpr->cp_scope)
		backscope = reopen_local_scope (dexpr->cp_scope);
	SAVE_CODE (dc);
	local_declaration (O = new_stream (), 0);
	RESTOR_CODE;
	free (dc);
	if (backscope) restore_local_scope (backscope);

	dexpr->de [cc] = combine_output (O);
	r->isconst = r->lvalue = false;
	r->t = lookup_local_obj (nn, 0);
	return r->e = sintprintf (alloctok (2), nn, -1);
}

static Token *autocast_arg (Token **arg, typeID proto_type, typeID arg_type)
{
	/* Feature: auto-(up)cast inheritance in function parameters */
	if (proto_type != arg_type && isstructptr (arg_type) &&
	   (isstructptr (proto_type) || isstructure (proto_type))) {
		recID vrr = aliasclass (base_of (arg_type));
		recID prr = aliasclass (dbase_of (proto_type));
		Token *path;
		int vp;
		/* really is an ancestor */
		if (vrr != prr && (vp = is_ancestor (vrr, prr, &path, false))) {
			Token *tmp = hier_upcast (*arg, path, vp == 2);
			free (*arg);
			*arg = tmp;
		}
	}
	return *arg;
}

/* Function call. This is supposed to be quite more complex */
static Token *rewr_fcall (bexpr *e, rewrret *r)
{
	int i, c, argc, *undone;
	typeID *argtypes = allocaint (e->nop + 12) + 1;
	bool *tmpvs = allocaint (e->nop + 12) + 1;
	flookup F = { .dflt_args=0, .oname=0 };
	bool this_trampoline = false;
	int skip_one = 0;
	Token **argback, gnn = 0;

	/* __enumstr__() not a real function */
	if (e->expr [0] == RESERVED___enumstr__ && e->operators [0] == 1)
		return do_enumstr (e, r);
	if (e->expr [0] == RESERVED___inset__)
		return do_inset (e, r);

	if (ISSYMBOL (e->expr [0]) && e->operators [0] == 1 && lookup_object (e->expr [0])
	 && !have_function (Global, e->expr [0]))
		return rewr_declexpr (e, r);

	tmpvs [-1] = false;

	argc = e->nop - 1;
	if (e->operators [1] == e->operators [0] + 1)
		argc = 0;

	/* rewrite all arguments so we can search for
	 * overloaded functions  */
	argback = (Token**) alloca ((2 + argc) * sizeof *argback) + 1;
	undone = (int*) alloca ((2 + argc) * sizeof *undone) + 1;
	for (i = 0; i < argc; i++) {
		/* ----* these are used for power varargs *---- */
		intdup_alloca (argback [i], e->branch [i + 1]);
		undone [i] = dexpr->c;
		/* -------------------------------------------- */
		r->tmpv = false;

		/*++++++++++++++++++++++++*/
		rewr_branch (e, i + 1, r);
		/*++++++++++++++++++++++++*/

		if (r->refalloca)
			expr_error ("Aaaaaaargh! alloca in function arguments!");
		argtypes [i] = bt_promotion (r->t);
		tmpvs [i] = r->tmpv;
	}
	argtypes [argc] = INTERNAL_ARGEND;
	argback [argc] = 0;

	OUTSTREAM O = new_stream ();

	/* Single symbol followed by () */
	if (ISSYMBOL (e->expr [0]) && e->operators [0] == 1) {
		int lerr = -1;
		Token *path = 0, vpath [64];

		/* Avoid virtual call if self recursive member call */
		if (objective.yes && e->expr [0] == objective.efunc
		&& lookup_function_member (objective.class, e->expr [0], argtypes - 1, &F, false)>0
		&& F.oname == objective.func)
			goto self_recursive;

		/* If auto function calls pure virtual, do invalid thing */
		if (objective.yes && !objective.polymorph && objective.recording
		&& Is_pure_virtual (objective.class, e->expr [0], argtypes - 1, &F)) {
			usage_call_pure ();
		   	lookup_virtual_function_member (objective.class, e->expr [0],
							argtypes - 1, vpath, &F);
			goto insist_virtual;
		}

		/* Feature: Virtual Functions are pointers to functions */
		if ((objective.yes) && (objective.polymorph) &&
		   (lookup_virtual_function_member (objective.class,
				 e->expr [0], argtypes - 1, vpath, &F))) insist_virtual: {

			SET_MAYTHROW (F);
			if (!objective.have_this)
				expr_error ("modular functions can't do virtual calls");

			r->t = F.t;
			sintprintf (frealloc (&e->branch [0], intlen (vpath) + 4),
				    RESERVED_this, POINTSAT, ISTR (vpath), -1);

			if (F.flagz & FUNCP_MODULAR) {
				skip_one = 1;
				goto dont_add_this1;
			}

			int i, l=l;

			++argc; --argtypes; --tmpvs; --argback; --undone;
			recID r1 = aliasclass (objective.class);
			recID r2 = aliasclass (base_of (argtypes [0]));

			path = 0;
			if (r1 != r2)
			   l = is_ancestor (r1, r2, &path, false);
			for (i = 1; e->branch [i]; i++);
			for (; i > 0; i--) e->branch [i + 1] = e->branch [i];
			e->branch [1] = alloctok (5 + (path ? intlen (path) : 0));
			if (!path)
				sintprintf (e->branch [1], RESERVED_this, -1);
			else	/* Inheritance path */
				sintprintf (e->branch [1], l == 2 ? BLANKT : '&', RESERVED_this,
					    POINTSAT, ISTR (path), -1);
		dont_add_this1:;
		} else
		/* ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ ++ +*/
		/* Feature: member calls member */
		if ((objective.yes) &&
		   (lookup_function_member (objective.class, e->expr [0],
				 argtypes - 1, &F, false)) > 0) self_recursive: {
			SET_MAYTHROW (F);

			/* SubFeature: pure non-virtual + auto */
			if (F.flagz & FUNCP_PURE && !objective.polymorph) {
				if (objective.recording)
					usage_call_pure ();
			}

			if (objective.recording)
				usage_fcall (F.oname);
			e->branch [0][0] = F.oname;
			r->t = F.t;

			if (F.flagz & FUNCP_MODULAR) {
				skip_one = 1;
				goto dont_add_this;
			}

			if (!objective.have_this)
				expr_error ("modular cannot call non-modular!");

			int i, v=v;
			recID ob;
			++argc; --argtypes; --tmpvs; --argback; --undone;
			ob = base_of (argtypes [0]);

			if (objective.recording)
				usage_upcast (ob);
			recID r1 = aliasclass (objective.class);
			recID r2 = aliasclass (ob);

			/* construct upcast path of 'this' */
			path = 0;
			if (r1 != r2)
				v = is_ancestor (r1, r2, &path, !objective.polymorph);

			for (i = 1; e->branch [i]; i++);
			for (; i > 0; i--) e->branch [i + 1] = e->branch [i];
			e->branch [1] = alloctok (4 + (path ? intlen (path) : 0));
			if (!path)
				sintprintf (e->branch [1], RESERVED_this, -1);
			else	/* Inheritance path */
				sintprintf (e->branch [1], v == 1 ? '&' : BLANKT ,
					    RESERVED_this, POINTSAT, ISTR (path), -1);
		dont_add_this:;
		} else
		/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
		if ((lerr = xlookup_function (Global, e->expr [0], argtypes, &F)) > 0) {
			SET_MAYTHROW (F);
			r->t = F.t;
			e->branch [0][0] = F.oname;
			if (e->expr [0] == INTERN_alloca)
				r->refalloca = true;
		} else if ((r->t = lookup_local_obj (e->expr [0], &gnn)) != -1
		       || (r->t = lookup_global_object (e->expr [0])) != -1) {

			if (isfptr (r->t)) {
				if (gnn) e->expr [0] = gnn;
				r->t = ptrdown (r->t);
				may_throw = true;
			} else
			/* Feature: overloading fcall operator () */
			if (isstructure (r->t) || (isstructptr (r->t)
			&& has_oper_fcall (dbase_of (r->t)))) ovrld_fcall: {
				frealloc (&e->branch [0], 4);
				sintprintf (e->branch [0], e->expr [0], isstructure (r->t) ?
					    '.' : POINTSAT, RESERVED_oper_fcall, -1);
				goto fmemb_call0;
			}
			/* ()()()()()()()()()()()()()()()()()()() */
			else expr_error ("not a pointer to function");

		} else if ((r->t = expr_is_class (e->branch[0])) && has_oper_fcall (base_of (r->t)))
			goto ovrld_fcall;
		else if (lerr == -1) expr_error_undef (e->branch [0][0], 1);
		else expr_errort ("Argument number mismatch", e->branch [0][0]);

		/* Feature: Invoke default arguments */
		if (F.dflt_args) {
			for (c = 0; F.dflt_args [c]; c++);
			e->branch = (Token**) realloc (e->branch, (argc + c + 2) * sizeof (Token*));
			for (i = 0; i < c; i++) {
				rewrret R = INIT_RWR;
				e->branch [argc + i + 1] = intdup (F.dflt_args [i]);

				/*++++++++++++++++++++++++++++++++*/
				rewr_branch (e, argc + i + 1, &R);
				/*++++++++++++++++++++++++++++++++*/

				argtypes [argc + i] = R.t;
			}
			e->branch [i + argc + 1] = 0;
			argtypes [argc += c] = INTERNAL_ARGEND;
		}
		/*-++-**-++-**-++-**-++-**-++-**-++-**/
	} else {
	/* expression followed by ()
	 * interesting cases are E1.SYMBOL () and E1->SYMBOL ()
	 * because we actually use member functions there
	 * w/o the feature the expression is a classic C pointer to function
	 */

	fmemb_call0:;
		Token *sv1 = allocaint (intlen (e->branch [0]) + 1);
		intcpy (sv1, e->branch [0]);

	fmemb_call:;

		/* Feature: normal function calls member function */
		bexpr E = { .expr = e->branch [0] };
		break_expr (&E);
		if (fork_branches (&E)) {
			Token fop = E.expr [E.operators [0]];
			if (fop == '.' || fop == POINTSAT) {
				/* This is (*it) */
				r->t = rewr_membcall (O, e, &E, --argtypes, --tmpvs, &argc, &F);
				if (r->t == -1) {
					/* ...or maybe not */
					++argtypes, ++tmpvs;
					goto no_oop;
				}
				if (F.flagz & FUNCP_MODULAR)
					++argtypes, ++tmpvs, skip_one = 1;
				else this_trampoline = tmpvs [0], --argback, --undone;
			} else no_oop: {
			/* This is the classic C case. w/o the feature */

				/*++++++++++++++++++*/
				rewr_branch (e, 0, r);
				/*++++++++++++++++++*/

				if (isfptr (r->t)) r->t = ptrdown (r->t);
				/* Feature: overload () on obj complex expr */
				else if (isstructure (r->t) || (isstructptr (r->t)
				&& has_oper_fcall (base_of (r->t)))) {
					Token *nb = alloctok (intlen (sv1) + 6);
					sintprintf (nb, ISTR (sv1),
					    isstructure (r->t) ?  '.' : POINTSAT,
					    RESERVED_oper_fcall, -1);
					free (e->branch [0]);
					e->branch [0] = nb;
					goto fmemb_call;
				}
				/* ()()()()()()()()()()()()()()()()()()()() */
				else if (!isfunction (r->t))
					expr_error ("Not a pointer to function");
				else may_throw = true;
			}
			freebranches (&E);
		} else parse_error (0, "this should not happen");
		/* ++++++++++++++++++++++++++++++++++++++++++++++ */

	}


	/* check in the types of the arguments
	   do conversions where needed  */
	bool need_trampoline = false;
	Token *elp_code = 0, elp_ret = 0, *elp_closure = 0, *vargv = 0, *vargc = 0;
	typeID *argt = open_typeID (r->t) + 2 + skip_one;
	for (i = 0; argt [i] != INTERNAL_ARGEND
	&& argt [i] != B_ELLIPSIS; i++) {

		/* Feature: elliptic varargs */
		if (typeID_elliptic (argt [i])) {
			Token tmp [50];
			int j;
			typeID tb = elliptic_type (argt [i]);

			/* pass (argv, argc) */
			if (argtypes [i] != INTERNAL_ARGEND && ptrup (tb) == argtypes [i]
			 && argtypes [i + 1] != INTERNAL_ARGEND
			 && bt_promotion (argtypes [i + 1]) == typeID_int
			 && argtypes [i + 2] == INTERNAL_ARGEND)
				break;

			elp_ret = internal_identifier2 ();
			vargv = allocaint (2);
			sintprintf (vargv, elp_ret, -1);
			vargc = allocaint (12);
			sintprintf (vargc, RESERVED_sizeof, elp_ret, '/', 
				    RESERVED_sizeof, '*', elp_ret, -1);
			OUTSTREAM M = new_stream ();
			outprintf (M, '(', '{', -1);
			if (isstructure (tb) && has_ctors (base_of (tb))) {
				/* ----* undo rewritten exprs *---- */
				if (argback [i] && undone [i] != dexpr->c)
					undo_declexprs (undone [i]);
				/* -------------------------------- */
				Token *rr;
				int cnt = 0;
				bool nothrow;

				open_local_scope ();
				OUTSTREAM T = new_stream ();
				outprintf (T, '{', -1);
				for (j = i; argback [j]; j++)
					outprintf (T, ISTR (argback [j]), ',', -1);
				outprintf (T, i == j ? BLANKT : BACKSPACE, '}', -1);
				SAVE_CODE (combine_output (T));
				outprintf (T = new_stream (), iRESERVED_struct (base_of (tb)),
					   name_of_struct (base_of (tb)),
					   elp_ret, '[', RESERVED_0, ']', ';', -1);
				CLEAR_MAYTHROW;
				gen_array_ctors (T, 1, ptrup (tb), elp_ret, &cnt, 0);
				nothrow = TEST_MAYTHROW;
				rr = combine_output (T);
				intsubst1 (rr, RESERVED_0, new_value_int (cnt));
				if (nothrow && !EHUnwind && did_unwind)
					remove_unwind_stuff (rr);
				RESTOR_CODE
				outprintf (M, ISTR (rr), -1);
				free (rr);
				if (!EHUnwind) {
					gen_auto_destruction (T = new_stream (), nothrow);
					elp_closure = combine_output (T);
				}
				close_local_scope ();
			} else {
				outprintf (M, ISTR (build_type (tb, elp_ret, tmp)), '[', 
					   ']', '=', '{', -1);
				for (j = i; j < argc; j++)
					outprintf (M, ISTR (autocast_arg (&e->branch [j + 1],
						 tb, argtypes [j])) , ',', -1);
				outprintf (M, j==i ? BLANKT : BACKSPACE, '}', ';', -1);
			}
			elp_code = combine_output (M);
			argc = i;
			break;
		}
		/* ......................... */

		if (argtypes [i] == INTERNAL_ARGEND)
			break;

		/* Feature: structure by reference */
		if (isstructure (argt [i]) && isstructure (argtypes [i]) && by_ref (argt [i])) {
			if (tmpvs [i])
				need_trampoline = true;
			else
				e->branch [i + 1] = addressize (e->branch [i + 1]);
			argtypes [i] = ptrup (argtypes [i]);
		} else { tmpvs [i] = 0;
		/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
			if (isreference (argt [i]) && bt_promotion (argtypes [i]) ==
			bt_promotion (ptrdown (dereference (argt [i])))) {
				e->branch [i + 1] = addressize (e->branch [i + 1]);
				argtypes [i] = ptrup (argtypes [i]);
			}
		}

		/* Feature: auto-cast inheritance */
		autocast_arg (&e->branch [i + 1], argt [i], argtypes [i]);
		/* - - - - - - - - - - - - - - - */
	}

	tmpvs [i] = -1;

	/* Feature: call trampoline */
	if (this_trampoline) need_trampoline = tmpvs [0] = true;
	if (need_trampoline) e->branch [0][0] = F.oname = i_trampoline_func (&F, tmpvs);
	/* ^^^^^^^^^^^^^^^^^^^^^^^^ */

	r->isconst = false;
	r->lvalue = false;
	r->t = funcreturn (r->t);
	r->tmpv = !isreference (r->t) && isstructure (r->t);

	outprintf (O, ISTR (e->branch [0]), '(', -1);
	for (i = 0; i < argc; i++)
		outprintf (O, ISTR (e->branch [i + 1]), i < argc - 1 ? ',' : BLANKT, -1);
	outprintf (O, ')', -1);

	/* Feature: power varargs */
	if (elp_code) {
		outprintf (O, BACKSPACE, argc ? ',' : BLANKT, ISTR (vargv), ',',
			   ISTR (vargc), ')', -1);
		Token *fc = combine_output (O);
		outprintf (O = new_stream (), ISTR (elp_code), -1);
		if (!elp_closure) outprintf (O, ISTR (fc), ';', -1);
		else {
			if (funcreturn (F.t) != typeID_void) {
				Token yy = internal_identifiern (111);
				outprintf (O, RESERVED_typeof, '(', ISTR (fc), ')', yy, '=',
					   ISTR (fc), ';', ISTR (elp_closure), yy, ';', -1);
			} else outprintf (O, ISTR (fc), ';', ISTR (elp_closure), -1);
			free (elp_closure);
		}
		outprintf (O, '}', ')', -1);
	}

	r->e = combine_output (O);

	/* Feature: function returning reference is lvalue */
	dereference_call (r);
	/* & & & & & & & & & & & & & & & & & & & & & & & & */

#ifdef	DEBUG
	if (debugflag.PEXPR) {
	INTPRINTF ("express: ", e->branch [0]);
	PRINTF (COLS"("COLE" ");
	for (i = 0; i < argc; i++) {
		INTPRINT (e->branch [i + 1]);
		if (i < argc -1) PRINTF (COLS","COLE);
	}
	PRINTF (COLS")"COLE"\n");
	}
#endif

	return r->e;
}

/* Feature: the amazing postfix operator */
static Token *rewr_postfix (bexpr *e, rewrret *r)
{
	Token ix = internal_identifier1 ();
	rewrret R = INIT_RWR;

	/*++++++++++++++++++*/
	rewr_branch (e, 1, r);
	rewr_branch (e, 2, &R);
	/*++++++++++++++++++*/

	r->refalloca |= R.refalloca;
	r->isconst &= R.isconst;
	r->lvalue = false;

	r->e = alloctok (2 * intlen (e->branch [1]) + intlen (e->branch [2]) + 17);
	sintprintf (r->e, '(', '{', RESERVED___typeof__, '(', ISTR (e->branch [1]), ')', ix,
		    '=', ISTR (e->branch [1]), ';', ISTR (e->branch [2]), ';', ix, ';', '}',
		    ')', -1);
	return r->e;
}

/* Feature: perl =~ operator, convert to fcall */
static Token *rewr_perlop (bexpr *e, rewrret *r)
{
	Token *fexpr = alloctok (intlen (e->branch [0]) + 5);
	sintprintf (fexpr, perlop_regexp (e->branch [1][0]), '(', ISTR (e->branch [0]), ')', -1);
	return rewrite_expression (fexpr, r);
}

/* Feature: dereference mode, undisguise references */
static Token *rewr_dereference (bexpr *e, rewrret *r)
{
	SAVE_VAR (MODE_DEREFERENCE, true);
	/*++++++++++++++++++*/
	rewr_branch (e, 0, r);
	/*++++++++++++++++++*/
	RESTOR_VAR (MODE_DEREFERENCE);
	return r->e = intdup (e->branch [0]);
}

static bool is_unary_overloaded (rewrret*, Token, Token*, bool, int);
static bool is_binary_overloaded (Token, rewrret*, Token*, rewrret*, Token*, bool, int);

/* this is the heart of this whirlpool algorithm */
static Token *rewrite_expression (Token *e, rewrret *r)
{
#ifdef	DEBUG
	if (debugflag.PEXPR_EXTREME) {
		INTPRINTF ("Heart of algorithm with :", e);
	}
#endif
	if (e [0] == -1) return e;
	if (e [1] == -1) {
		if (ISVALUE (e [0]))
			return rewr_const (e, r);
		if (ISSYMBOL (e [0]))
			return rewr_terminal (e, r);
		if (e [0] == RESERVED_this)
			return rewr_this (e, r);
	}

	bexpr E = { .expr = e };
	Token *n = 0;

	E.expr = e;
	break_expr (&E);
	if (!fork_branches (&E))
		return e;

	rewrret R = INIT_RWR;

	Token oo, op0 = e [E.operators [0]];
	if (E.operators [0] == 0 && (oo = isunary_overloadable (op0))) {
		Token *sv = allocaint (intlen (E.branch [0]) + 1);
		intcpy (sv, E.branch [0]);

		/*++++++++++++++++++*/
		possible_undo
		rewr_branch (&E, 0, r);
		/*++++++++++++++++++*/

		if (is_unary_overloaded (r, oo, sv, E.esc_op, undode)) {
			n = r->e;
			goto skipper;
		}
	} else if (E.operators [0] > 0 && (oo = isbinary_overloadable (op0))) {
		Token *sv0 = allocaint (intlen (E.branch [0]) + 1);
		intcpy (sv0, E.branch [0]);
		Token *sv1 = allocaint (intlen (E.branch [1]) + 1);
		intcpy (sv1, E.branch [1]);

		possible_undo
		/*++++++++++++++++++*+*/
		rewr_branch (&E, 0, &R);
		/*++++++++++++++++++*+*/
		/*++++++++++++++++++*+*/
		if (op0 == ANDAND || op0 == OROR)
			rewr_branch_cpoint (&E, 1, r);
		else
			rewr_branch (&E, 1, r);
		/*++++++++++++++++++*+*/

		r->tmpv = R.tmpv;
		//if (op0 == '[') r->tmpv = false;

		if (is_binary_overloaded (oo, &R, sv0, r, sv1, E.esc_op, undode)) {
			n = r->e;
			goto skipper;
		}
	} else if (op0 == PLUSPLUS || op0 == MINUSMINUS) {
		Token *sv = allocaint (intlen (E.branch [0]) + 1);
		intcpy (sv, E.branch [0]);

		/*++++++++++++++++++*/
		possible_undo
		rewr_branch (&E, 0, r);
		/*++++++++++++++++++*/

		if (is_unary_overloaded (r, isunary_postfix_overloadable (op0), sv, E.esc_op,
											 undode)) {
			n = r->e;
			goto skipper;
		}
	} else if (op0 == '&')
		/*++++++++++++++++++*/
		rewr_branch (&E, 0, r);
		/*++++++++++++++++++*/
	else if (op0 == RESERVED_sizeof && E.et != SIZEOF_TYPE)
		/*++++++++++++++++++++++++++*/
		rewr_branch_cpoint (&E, 0, r);
		/*++++++++++++++++++++++++++*/
	else if (op0 != '.' && !(op0 == '(' && E.et == PARENTH_SYNTAX))
			r->tmpv = false;

	switch (op0) {
	case RESERVED_sizeof:
			n = (E.et == SIZEOF_TYPE) ?
			    rewr_sizeof_type (&E, r) :
			    rewr_sizeof (&E, r);	break;
	case RESERVED_new:
	case RESERVED_localloc:
			n = rewr_new (&E, r);		break;
	case RESERVED_delete:
			n = rewr_delete (&E, r);	break;
	case RESERVED_dereference:
			n = rewr_dereference (&E, r);	break;
	case RESERVED___declexpr__:
			n = rewr_declexpr (&E, r);	break;
	case '%':
	case RSH:
	case LSH:
	case '|':
	case '^':	n = rewr_bitop (&E, r, &R);	break;
	case '&':	n = (E.operators [0] > 0) ?
			    rewr_bitop (&E, r, &R) :
			    rewr_address (&E, r);	break;
	case '/':	n = rewr_numop (&E, r, &R);	break;
	case '*':	n = (E.operators [0] > 0) ?
			    rewr_numop (&E, r, &R) :
			    rewr_ptrind (&E, r);	break;
	case '<':
	case '>':
	case GEQCMP:
	case LEQCMP:
	case NEQCMP:
	case EQCMP:	n = rewr_relational (&E, r, &R);break;
	case '~':	n = rewr_complement (&E, r);	break;
	case '!':	n = rewr_not (&E, r);		break;
	case '+':	n = (E.operators [0] > 0) ?
			    rewr_add (&E, r, &R) :
			    rewr_usign (&E, r);		break;
	case '-':	n = (E.operators [0] > 0) ?
			    rewr_sub (&E, r, &R) :
			    rewr_usign (&E, r);		break;
	case MINUSMINUS:
	case PLUSPLUS:	n = rewr_incdec (&E, r);	break;
	case ANDAND:
	case OROR:	n = rewr_boolean (&E, r, &R);	break;
	case '=':	n = rewr_assign (&E, r, &R);	break;
	case '?':	n = rewr_conditional (&E, r);	break;
	case '[':	n = rewr_array (&E, r, &R);	break;
	case '{':	n = rewr_statmexpr (&E, r);	break;
	case '(':	n = (E.et == PARENTH_SYNTAX) ?
			    rewr_parenthesis (&E, r) :
			    (E.et == PARENTH_CAST) ?
			    rewr_cast (&E, r) :
			    (E.et == PARENTH_POSTFIX) ?
			    rewr_postfix (&E, r) :
			    rewr_fcall (&E, r);		break;
	case '.':	n = rewr_member (&E, r);	break;
	case POINTSAT:	n = rewr_pmember (&E, r);	break;
	case ',':	n = rewr_comma (&E, r, &R);	break;
	case PERLOP:	n = rewr_perlop (&E, r);	break;
	default:
		if (ISASSIGNMENT (e [E.operators [0]]))
			n = rewr_opassign (&E, r, &R);
		else expr_errort ("Not Implemented", e [E.operators [0]]);
	}

skipper:
	freebranches (&E);

	return n;
}

/******************************************************************************
	operator overloadings
	-- convert to function calls and rewrite
******************************************************************************/
static void undo_declexprs (int c)
{
	int i;
	for (i = c; i < dexpr->c; i++) {
		free (dexpr->de [i]);
		undo_local_obj (dexpr->obj [i]);
	}
	dexpr->c = c;
}

static bool is_unary_overloaded (rewrret *r, Token oo, Token *sv, bool force, int undode)
{
	Token *ne;
	typeID argt [] = { 0, INTERNAL_ARGEND };
	flookup F;
	bool svthis = sv [0] == RESERVED_this && sv [1] == -1;

	if (isunsafeop (oo) && ispointer (r->t) && !force)
		if (oo == RESERVED_oper_star || !svthis)
			return false;

	if (isstructure (r->t) || isstructptr (r->t)) {
		bool throuptr = isstructptr (r->t);

		if (lookup_function_member (base_of (r->t), oo, argt, &F, true) < 2)
			goto no_member;

		SET_MAYTHROW (F);
		ne = mallocint (intlen (sv) + 10);
		if (simpleexpr (sv))
		     sintprintf (ne, ISTR (sv), throuptr ? POINTSAT : '.', oo, '(', ')', -1);
		else sintprintf (ne, '(', ISTR (sv), ')', throuptr ? POINTSAT : '.',
				 oo, '(', ')', -1);
	} else no_member: {
		argt [0] = r->t;
		if (xlookup_function (Global, oo, argt, &F) < 2)
			return false;

		SET_MAYTHROW (F);
		ne = mallocint (intlen (sv) + 5);
		sintprintf (ne, oo, '(', ISTR (sv), ')', -1);
	}

	UNDO_REWRITE
	bexpr E = { .expr = ne };
	break_expr (&E);
	fork_branches (&E);
	rewr_fcall (&E, r);
	freebranches (&E);
	return true;
}

static bool is_binary_overloaded (Token oo, rewrret *r1, Token *e1, rewrret *r2, Token *e2, bool force, int undode)
{
	Token *ne;
	typeID argt [] = { 0, r2->t, INTERNAL_ARGEND };
	flookup F;
	bool e1this = e1 [0] == RESERVED_this && e1 [1] == -1;

	if (isunsafeop (oo) && ispointer (r1->t) && !force)
		/* skip overloading if unsafe && not invalid */
		switch (oo) {
		default: return false;
		 case RESERVED_oper_sub:
		 case RESERVED_oper_as_s:
			if (ispointer (r2->t) && !e1this) return false;
		 case RESERVED_oper_add:
		 case RESERVED_oper_as_a:
			if (bt_promotion (r2->t) == typeID_int && !e1this) return false;
		ncase RESERVED_oper_assign:
			if (e1this) break;
		 case RESERVED_oper_le:
		 case RESERVED_oper_gr:
		 case RESERVED_oper_greq:
		 case RESERVED_oper_leq:
		 case RESERVED_oper_neq:
		 case RESERVED_oper_eq:
			if (bt_promotion (r2->t) != typeID_float && !isstructure (r2->t))
				return false;
		ncase RESERVED_oper_andand:
		 case RESERVED_oper_oror:
			if (!isstructure (r2->t) && !e1this) return false;
		ncase RESERVED_oper_array:
			if (!e1this) return false;
		}


	if (isstructure (r1->t) || isstructptr (r1->t)) {
		bool throuptr = isstructptr (r1->t);

		if (lookup_function_member (base_of (r1->t), oo, argt, &F, true) < 2)
			goto no_member;

		SET_MAYTHROW (F);
		ne = mallocint (intlen (e1) + intlen (e2) + 12);

		if (e1this)	// don't include 'this' for auto-virtual hack
		     sintprintf (ne, oo, '(', ISTR (e2), ')', -1);
		else if (simpleexpr (e1))
		     sintprintf (ne, ISTR (e1), throuptr ? POINTSAT : '.',
				 oo, '(', ISTR (e2), ')', -1);
		else sintprintf (ne, '(', ISTR (e1), ')', throuptr ?
				 POINTSAT : '.', oo, '(', ISTR (e2), ')', -1);
	} else no_member: {
		argt [0] = r1->t;
		if (xlookup_function (Global, oo, argt, &F) <= 2)
			return false;

		SET_MAYTHROW (F);
		ne = mallocint (intlen (e1) + +intlen (e2) + 9);
		sintprintf (ne, oo, '(', '(', ISTR (e1), ')', ',', ISTR (e2), ')', -1);
	}

	UNDO_REWRITE
	bexpr E = { .expr = ne };
	break_expr (&E);
	fork_branches (&E);
	rewr_fcall (&E, r2);
	freebranches (&E);
	return true;
}
/******************************************************************************

	Interface entries

******************************************************************************/

static Token *cpoint_rewrite_expression (Token *e, rewrret *R)
{
	/* This is the basic entry point to rewrite_expression()
	   Setting a 'c-point' means that the *entire* expression is executed,
	   without 'ifs'.  For example A?B:C has three c-points.  One the
	   entire expression, one for 'B' and one for 'C'.  */ 
	Token *r;
	struct declexpr D = { .c = 0, .off = (dexpr ? dexpr->c + dexpr->off + 1 : 0) }, *Dp = &D;
	bool nothrow;

	SAVE_VAR (dexpr, Dp);
	open_local_scope ();
	dexpr->cp_scope = active_scope ();
	/* +++++++++++++++++++++++++ */
	CLEAR_MAYTHROW;
	r = rewrite_expression (e, R);
	nothrow = TEST_MAYTHROW;
	/* +++++++++++++++++++++++++ */
	if (D.c) {
		/* In here means that we have generated declaration-expressions.
		   put the entire thing in compound statement, print the decl-exprs
		   print the main expression, generate destructors */

		OUTSTREAM O = new_stream ();
		int i;

		outprintf (O, '(', '{', -1);
		for (i = D.c - 1; i >= 0; i--) {
			if (nothrow && !EHUnwind && did_unwind)
				remove_unwind_stuff (D.de [i]);
			outprintf (O, ISTR (D.de [i]), -1);
			free (D.de [i]);
		}
		if (R->t != typeID_void && scope_has_dtors ()) {
			Token rt = internal_identifier3 ();
			outprintf (O, RESERVED___typeof__, '(', ISTR (r), ')', rt, '=',
				   ISTR (r), ';', -1);
			gen_auto_destruction (O, nothrow);
			outprintf (O, rt, ';', '}', ')', -1);
		} else {
			outprintf (O, ISTR (r), ';', -1);
			if (scope_has_dtors ())
				gen_auto_destruction (O, nothrow);
			outprintf (O, '}', ')', -1);
		}
		free (r);
		R->e = r = combine_output (O);
	}
	close_local_scope ();
	RESTOR_VAR (dexpr);
	return r;
}

/* This is the interface function of this module.
   It will, advance to the end of the current expression,
   rewrite the expression according to our extensions
   and eventually return the rewritten expression 
   token string along with info for whether it's constant.
   Expression errors longjmp here and in this case
   the return has ok=false.  */
   

#define PROTECT_UNWIND_SET \
	Token *scode = CODE;\
	bool mdr = MODE_DEREFERENCE;\
	struct declexpr *dd = dexpr;\

#define PROTECT_UNWIND_RESTOR \
	{\
		CODE = scode;\
		MODE_DEREFERENCE = mdr;\
		dexpr = dd;\
	}

void parse_expression_string (Token *expr, exprret *E)
{
	rewrret rez = INIT_RWR;
	jmp_buf ENV;

#ifdef	DEBUG
	if (debugflag.PEXPR) {
		PRINTF ("The expression is ["COLS);
		INTPRINT (expr);
		PRINTF (COLE"]\n");
	}
#endif

	if (expr [0] == -1) {
		E->ok = true;
		E->newExpr = expr;
		E->type = lasttype = typeID_void;
		return;
	}

	PROTECT_UNWIND_SET
	E->ok = false;
	if (setjmp (ENV) == 0) {
		set_catch (&ENV, last_location, expr, 0);
#ifdef	DEBUG
	if (debugflag.PEXPR)
		PRINTF ("\n");
#endif
		cpoint_rewrite_expression (expr, &rez);
		E->ok = true;
		E->isconstant = rez.isconst;
		E->newExpr = rez.e;
		E->type = lasttype = rez.t;
		if (rez.e != expr) free (expr);
	} else PROTECT_UNWIND_RESTOR
	clear_catch ();
}

NormPtr parse_expression (NormPtr p, exprret *E, int et)
{
	NormPtr p1 = p;

	last_location = p;
	p = skip_expression (CODE, p1, et);
	parse_expression_string (intndup (CODE + p1, p - p1), E);
	return p;
}

static bool need_dereference (typeID ret, typeID have)
{
	int *t1 = open_typeID (ret), *t2 = open_typeID (have);
	return intcmp (t1 + 2, t2 + 1) == 0;	
}

NormPtr parse_expression_retconv (NormPtr p, exprret *E, typeID cast, int et)
{
	/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
	p = parse_expression (p, E, et);
	/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
	if (E->ok && lasttype != cast) {
		if (isreference (cast)) {
			cast = dereference (cast);
			if (cast == lasttype)
				return p;
			if (need_dereference (cast, lasttype)) {
				/* hack-kludge: may break others XXX */
				if (E->newExpr [1] == -1) E->isconstant = 1;

				E->newExpr = addressize (E->newExpr);
				E->type = lasttype = ptrup (lasttype);
				if (lasttype == cast)
					return p;
			}
		}
		if (isstructptr (cast) && isstructptr (lasttype)) {
			recID vrr = aliasclass (base_of (lasttype));
			recID prr = aliasclass (base_of (cast));
			Token *path;
			int vp;
			/* really is an ancestor */
			if (vrr != prr && (vp = is_ancestor (vrr, prr, &path, false))) {
				Token *tmp;
				tmp = hier_upcast_nonull (E->newExpr, path, vp == 2, prr, vrr);
				free (E->newExpr);
				E->newExpr = tmp;
			}
		}
	}
	return p;
}

NormPtr parse_const_expression (NormPtr p, exprret *E)
{
	NormPtr p1 = p;
	Token *expr;
	rewrret dummy = INIT_RWR;
	jmp_buf ENV;

	last_location = p;
	p = skip_expression (CODE, p, CONST_EXPR);
	expr = intndup (CODE + p1, p - p1);
	if (expr [0] == -1) {
		E->ok = true;
		E->newExpr = expr;
		E->type = typeID_void;
		return p;
	}

	PROTECT_UNWIND_SET
	if (setjmp (ENV) == 0) {
		set_catch (&ENV, p1, expr, 0);
#ifdef	DEBUG
	if (debugflag.PEXPR)
		PRINTF ("\n");
#endif
		cpoint_rewrite_expression (expr, &dummy);
		if (!dummy.isconst)
			parse_error (p, "Constant expression expected");
		E->ok = true;
		E->isconstant = dummy.isconst;
		E->newExpr = dummy.e;
		E->type = dummy.t;
		if (dummy.e != expr) free (expr);
	} else PROTECT_UNWIND_RESTOR
	clear_catch ();

	return p;
}

void rewrite_designator (typeID t, Token des[])
{
	Token *expr = mallocint (intlen (des) + 1);
	rewrret R = INIT_RWR;
	jmp_buf ENV;

	intcpy (expr, des);
	PROTECT_UNWIND_SET
	if (setjmp (ENV) == 0) {
		set_catch (&ENV, 0, expr, 0); /* XXX */
		cpoint_rewrite_expression (expr, &R);
		intcpy (des, R.e);
		if (R.e != expr) free (R.e);
	} else PROTECT_UNWIND_RESTOR
	clear_catch ();
	free (expr);
}

Token *rewrite_ctor_expr (Token *e)
{
	rewrret rez = INIT_RWR;
	jmp_buf ENV;

	PROTECT_UNWIND_SET
	if (setjmp (ENV) == 0) {
		set_catch (&ENV, 0, e, 0);
#ifdef	DEBUG
	if (debugflag.PEXPR)
		PRINTF ("\n");
#endif
		cpoint_rewrite_expression (e, &rez);
	} else {
		rez.e = 0;
		PROTECT_UNWIND_RESTOR
	}
	clear_catch ();

	return rez.e;
}

bool is_object_in_scope (Token m)
{
	return is_enumconst (m) || lookup_local_obj (m, 0) != -1 || lookup_global_object (m) != -1
	|| (objective.yes && lookup_variable_member (objective.class, m, 0, 0, 0) != -1);
}
